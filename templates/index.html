<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualización en Tiempo Real</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/exporting.js"></script>
    <script src="https://code.highcharts.com/modules/export-data.js"></script>
    <script src="https://code.highcharts.com/modules/accessibility.js"></script>
    
</head>
<body>
    <h1>Visualización en Tiempo Real Sensor de luz</h1>
    <canvas id="real-time-chart"></canvas>
    <br>
    <hr>

    <figure class="highcharts-figure">
        <div id="container"></div>
        <p class="highcharts-description">
            gráfico de Highcharts
        </p>
    </figure>
    
    <div class="ld-form">
        <div class="ld-row">
            <label class="ld-label">
                Habilitar Actualización Automática
            </label>
            <input type="checkbox" checked="checked" id="enablePolling"/>
        </div>
        <div class="ld-row">
            <label class="ld-label">
                Frecuencia de Actualización (segundos)
            </label>
            <input class="ld-time-input" type="number" value="2" id="pollingTime"/>
        </div>
        <div class="ld-row">
            <label class="ld-label">
                URL de los Datos
            </label>
            <input class="ld-url-input" type="text" id="fetchURL"/>
        </div>
    </div>
    <script>
        // ---------------------
        var datoTime = 0;
var datoLuz = 0;
var datoTemperatura = 0;
var lastUpdateTime = 0;
var updateInterval = 1000; // Intervalo de actualización en milisegundos
var maxIdleTime = 5000; // Tiempo máximo sin actualizaciones en milisegundos
var dataStopped = false;

document.addEventListener('DOMContentLoaded', function () {
    // Configura el gráfico en el canvas
    var ctx = document.getElementById('real-time-chart').getContext('2d');
    var realTimeChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],  // Etiquetas de tiempo
            datasets: [{
                label: 'Datos del Sensor',
                data: [],   // Datos del sensor
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1,
                fill: false
            }]
        },
        options: {
            scales: {
                x: [{
                    type: 'realtime',
                    realtime: {
                        duration: 20000,  // Duración de la ventana de visualización en milisegundos
                        refresh: 1000,   // Frecuencia de actualización en milisegundos
                        delay: 1000       // Retraso inicial en milisegundos
                    }
                }]
            }
        }
    });

    // Función para realizar solicitudes HTTP periódicas y actualizar el gráfico
    function fetchData() {
        const apiUrl = '/api/get_last_data';

        fetch(apiUrl)
            .then(handleResponse)
            .then(updateChart)
            .catch(handleError)
            .finally(scheduleNextRequest);
    }

    function handleResponse(response) {
        if (!response.ok) {
            throw new Error(`Error de red: ${response.status}`);
        } else {
            return response.json();
        }
    }

    function updateChart(data) {
        const { time, medicionLuz, medicionTemperatura } = JSON.parse(data);

        // Verifica si el tiempo y los datos son diferentes
        if (time !== datoTime || medicionLuz !== datoLuz || medicionTemperatura !== datoTemperatura) {
            datoTime = time;
            datoLuz = medicionLuz;
            datoTemperatura = +medicionTemperatura.toFixed(2);

            // Actualiza el gráfico con los nuevos datos
            realTimeChart.data.labels.push(time);
            realTimeChart.data.datasets[0].data.push(medicionLuz);
            realTimeChart.update();

            // Actualiza la última vez que se recibió un dato
            lastUpdateTime = Date.now();
            dataStopped = false;
        } else {
            // Si los datos son iguales, verifica si ha pasado el tiempo máximo sin actualizaciones
            if (!dataStopped && Date.now() - lastUpdateTime > maxIdleTime) {
                // Indica que se ha detenido la actualización de datos
                dataStopped = true;
                console.log('La actualización de datos se ha detenido.');
            }
        }
    }

    function handleError(error) {
        console.error('Error al obtener datos:', error);
        datoLuz = null;
        datoTemperatura = null;
    }

    function scheduleNextRequest() {
        setTimeout(fetchData, updateInterval);
    }

    // Inicia la función para realizar solicitudes HTTP periódicas
    fetchData();

    // ---------------------
// Configuración del gráfico de Highcharts

// On chart load, start an interval that adds points to the chart and animate
// the pulsating marker.
    const onChartLoad = function () {
        const chart = this,
            series1 = chart.series[0];
            series2 = chart.series[1];

        setInterval(function () {
            const x = (new Date()).getTime(), // current time
                y1 = datoTemperatura;
                y2 = datoLuz;

            series1.addPoint([x, y1], true, true);
            series2.addPoint([x, y2], true, true);
        }, 1000);
    };

    // Create the initial data
    const data = (function () {
        const data = [[], []];
        const time = new Date().getTime();

        for (let i = -19; i <= 0; i += 1) {
            data[0].push({
                x: time + i * 1000,
                y: 0
            });
            data[1].push({
                x: time + i * 1000,
                y: 2
            });
        }
        return data;
    }());

    // Plugin to add a pulsating marker on add point
    Highcharts.addEvent(Highcharts.Series, 'addPoint', e => {
        const point = e.point,
            series = e.target;

        if (!series.pulse) {
            series.pulse = series.chart.renderer.circle()
                .add(series.markerGroup);
        }

        setTimeout(() => {
            series.pulse
                .attr({
                    x: series.xAxis.toPixels(point.x, true),
                    y: series.yAxis.toPixels(point.y, true),
                    r: series.options.marker.radius,
                    opacity: 1,
                    fill: series.color
                })
                .animate({
                    r: 20,
                    opacity: 0
                }, {
                    duration: 1000
                });
        }, 1);
    });


    Highcharts.chart('container', {
        chart: {
            type: 'spline',
            events: {
                load: onChartLoad
            }
        },

        time: {
            useUTC: false
        },

        title: {
            text: 'Grado de Temperatura en Tiempo Real'
        },

        accessibility: {
            announceNewData: {
                enabled: true,
                minAnnounceInterval: 15000,
                announcementFormatter: function (allSeries, newSeries, newPoint) {
                    if (newPoint) {
                        return 'New point added. Value: ' + newPoint.y;
                    }
                    return false;
                }
            }
        },

        xAxis: {
            type: 'datetime',
            tickPixelInterval: 150,
            maxPadding: 0.1
        },

        yAxis: {
            title: {
                text: 'Grado de Temperatura (°C)'
            },
            plotLines: [
                {
                    value: 0,
                    width: 1,
                    color: '#808080'
                }
            ]
        },

        tooltip: {
            headerFormat: '<b>{series.name}</b><br/>',
            pointFormat: '{point.x:%d-%m-%Y %H:%M:%S}<br/>{point.y:.2f} °C'
        },

        legend: {
            enabled: false
        },

        exporting: {
            enabled: false
        },

        series: [
            {
                name: 'Temperatura',
                lineWidth: 2,
                color: Highcharts.getOptions().colors[2],
                data: data[0]
            },
            {
                name: 'Luz',
                lineWidth: 2,
                color: Highcharts.getOptions().colors[1],
                data: data[1]
            }
        ]
    });

    // Función para realizar solicitudes HTTP periódicas y actualizar el gráfico de Highcharts
    function fetchDataAndUpdateHighcharts() {
        const apiUrl = '/api/get_last_data';

        fetch(apiUrl)
            .then(handleResponse)
            .then(updateHighcharts)
            .catch(handleError)
            .finally(scheduleNextHighchartsUpdate);
    }

    function updateHighcharts(data) {
        const { time, medicionLuz, medicionTemperatura } = JSON.parse(data);

        // Verifica si el tiempo y los datos son diferentes
        if (time !== datoTime || medicionLuz !== datoLuz || medicionTemperatura !== datoTemperatura) {
            datoTime = time;
            datoLuz = medicionLuz;
            datoTemperatura = +medicionTemperatura.toFixed(2);

            // Actualiza el gráfico de Highcharts con los nuevos datos
            const x = (new Date()).getTime();
            const y = datoTemperatura;
            highchartsSeries.addPoint([x, y], true, true);

            // Actualiza la última vez que se recibió un dato
            lastUpdateTime = Date.now();
            dataStopped = false;
        } else {
            // Si los datos son iguales, verifica si ha pasado el tiempo máximo sin actualizaciones
            if (!dataStopped && Date.now() - lastUpdateTime > maxIdleTime) {
                // Indica que se ha detenido la actualización de datos
                dataStopped = true;
                console.log('La actualización de datos de Highcharts se ha detenido.');
            }
        }
    }

    function scheduleNextHighchartsUpdate() {
        setTimeout(fetchDataAndUpdateHighcharts, updateInterval);
    }

    // Inicia la función para realizar solicitudes HTTP periódicas y actualizar el gráfico de Highcharts
    fetchDataAndUpdateHighcharts();
});

    </script>
</body>
</html>
